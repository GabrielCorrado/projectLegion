package CombinationOfLvl1_2_3;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.event.MouseEvent;
import java.awt.geom.Point2D;

import javax.swing.JPanel;
import javax.swing.event.MouseInputListener;



public class Board extends JPanel implements MouseInputListener {
	public Cell[][] cells;
	public Cell_2[][] cells2;
	public GenCell[][] display;
	private int size; //these are the numbers of cells in the board, NOT the graphical dimensions of the board
	private static final int EXTRA_BOARD_SPACE = 50;
	private Color c;
	public Color polarity;
	private int cellSize;
	private Agent[] agents;
	private double middleOfAgent;
	private int agentSize;
	private boolean agentsPastBoard = false;
	private Color agentColor = Color.green;
	
	public Board(int width, int height, int size, int typeBoard) {
		//set preferred graphical dimensions of the board
		setPreferredSize(new Dimension(width, height));
		this.size = size;
		display = new GenCell[size*2][size];
		//set the graphical dimensions of the cells themselves
		//the cells are always square, but the space they take up is constrained by the width and height of the board
		//and by the number of cells.
		//note that since this is an int, it rounds (down, in particular). so we will never see
		//those ugly irregularly sized cells
		cellSize = ((width/2)-2*EXTRA_BOARD_SPACE)/size;
		//set the swarm agent size
		agentSize = (int)(0.7*cellSize);
		middleOfAgent =  0.5*agentSize;
		
		cells = new Cell[size][size];
		for (int row = 0; row < cells.length; row++) {
			for (int col = 0; col < cells[row].length; col++) {
				if (typeBoard==0)
				{
					int rand = (int) (Math.random()*2);
					if (rand == 0)
					{
						c = Color.black;
					}
					else
					{
						c = Color.white;
					}
					cells[row][col] = new Cell(EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, c);
				}
				else if (typeBoard==1)
				{
					if (row%2 == col%2)
					{
						c = Color.black;
					}
					else
					{
						c = Color.white;
					}
					cells[row][col] = new Cell(EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, c);

				}

			}
		
		//generate the swarm; kirsch suggested, say, 30 agents, so we're trying 10 right now
		//we've tried moving the swarm agents every frame with mousedragged... it can handle at least 500 with no
		//visible slowdown.
		agents = new Agent[100];
		for (int i = 0; i < agents.length; i++) {
			//these generate in a random spot on the board itself, with a random vector that makes no effing sense yet
			agents[i] = new Agent((int)(EXTRA_BOARD_SPACE+Math.random()*width-2*EXTRA_BOARD_SPACE), (int)(EXTRA_BOARD_SPACE+Math.random()*width-2*EXTRA_BOARD_SPACE), agentSize, new Point2D.Double(Math.random()*10-5, Math.random()*10-5), agentColor);
			
			if (agents[i].x < EXTRA_BOARD_SPACE || agents[i].y < EXTRA_BOARD_SPACE || agents[i].x+agentSize > EXTRA_BOARD_SPACE+(size*2*cellSize) || agents[i].y+agentSize > EXTRA_BOARD_SPACE+(size*cellSize))
			{
				agents[i].agentPastBoard = true;
				agents[i].setColor(new Color(0,1,0,0));
			}
			else
			{
				agents[i].setColor(Color.green);
			}
		}
		
		this.addMouseListener(this);
		this.addMouseMotionListener(this);
		}
		//In regards to polarity, a checker board with black in the top left is red, the other is blue.
				if(cells[0][0].getColor()==Color.BLACK)
				{
					polarity = Color.RED;
				}
				else
				{
					polarity = Color.BLUE;
				}
				
				//layer 2 initial construction
				layer2(polarity);
	}
	
	protected void layer2(Color polarity)
	{
		
		cells2 = new Cell_2[size][size];
		
		
		for (int row = 0; row < cells.length; row++) {
			for (int col = 0; col < cells[row].length; col++) {

				if(polarity == Color.RED)
					//if the top left is black
				{
					if(cells[row][col].getColor() == Color.BLACK)
						//if the layer 1 cell is black
					{
						if(col%2 == row%2)
							//if its in a spot that should be black
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.RED);
								//then you are the same polarity as cell[0][0]
						}
						else
							//if its in a spot that SHOULDN'T be black
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.BLUE);
								//then you are in the opposite polarity than cells[0][0]
						}
					}
					else
						//if the layer 1 cell is white
					{
						if(col%2 == row%2)
							//if its in a spot that SHOULDN'T be 
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.BLUE);
								// then its in the opposite polarity than cells[0]
						}
						else
							//if its in a spot that should be white
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.RED);
								//then its in the same polarity as cells[0][0]
						}
					}
				}
				else
				{
					if(cells[row][col].getColor() == Color.WHITE)
					{
						if(col%2 == row%2)
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.RED);
						}
						else
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.BLUE);
						}
					}
					else
					{
						if(col%2 == row%2)
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.BLUE);
						}
						else
						{
							cells2[row][col] = new Cell_2(800+EXTRA_BOARD_SPACE+row*cellSize, EXTRA_BOARD_SPACE+col*cellSize, cellSize, Color.RED);
						}
					}
				}
			}
		}
	}
	
	protected void paintComponent(Graphics arg0) {
		super.paintComponent(arg0);
		
		Graphics2D g = (Graphics2D)arg0;
		
		for (int row = 0; row < size*2; row++) {
			for (int col = 0; col <size; col++) {
				if (row<size)
				{
					display[row][col] = cells[row][col];
				}
				else
				{
					display[row][col] = cells2[row-size][col];
				}
				display[row][col].draw(g);
			}
		}
		
		for (int i = 0; i < agents.length; i++) {
			if (agents[i].agentPastBoard == true)
			{
				agents[i].setColor(new Color(0,1,0,0));
			}
			else
			{
				agents[i].setColor(Color.green);
			}
			agents[i].draw(g);
		}
	}
	
	public void step() {
		//this is our new, improved step method, because the cells have no step method of their own.
		
		for (int i = 0; i < agents.length; i++) {
			//move the agents according to their vectors; i dunno how the eff to do this
			//will this work???
			agents[i].step();
		}
		
		layer2(polarity);
	}
	

	@Override
	public void mouseClicked(MouseEvent arg0) {
		// TODO Auto-generated method stub

		//for each agent, have the agent decide randomly whether to flip its cell's color
		for (Agent agent : agents) {
			if (Math.random() < 0.05) {
				//to decide which cell the agent is in... this is bad :( need to possibly flip it around, or decide
				//which cell each agent is in each time they move, in fact this could be determined using each agent's
				//x and y rather than searching all the cells... but this should be runnable for now
				for (int row = 0; row < cells.length; row++) {
					for (int col = 0; col < cells[row].length; col++) {
						if (cells[row][col].contains(agent.getCenterX(), agent.getCenterY())) {
							cells[row][col].flipColor();
						}
					}
				}
			}
			//agent.x < EXTRA_BOARD_SPACE   AKA left border
			//agent.y < EXTRA_BOARD_SPACE   AKA top border
			//agent.x > EXTRA_BOARD_SPACE+(size*2*cellSize)   AKA right border
			//agent.y > EXTRA_BOARD_SPACE+(size*cellSize)   AKA bottom border
			//you must add agentSize to the right border and the bottom border. This is because ellipses are essentially circles with boxes in them and the top left corner starts
			//at (0,0). Therefore you want to add agentSize to the right and the bottom so it knows if the tip of the circle is at the point where the board cannot go anymore.
			if (agent.x < EXTRA_BOARD_SPACE || agent.y < EXTRA_BOARD_SPACE || agent.x+agentSize > EXTRA_BOARD_SPACE+(size*2*cellSize) || agent.y+agentSize > EXTRA_BOARD_SPACE+(size*cellSize))
			{
				agent.agentPastBoard = true;
				agent.setColor(new Color(0,1,0,0));
			}
			else
			{
				agent.agentPastBoard = false;
				agent.setColor(Color.green);
			}
		}
		
		step();
		repaint();
		
	}

	@Override
	public void mouseEntered(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseExited(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mousePressed(MouseEvent arg0) {
		// TODO Auto-generated method stub

		
		
		
	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void mouseDragged(MouseEvent e) {
		// TODO Auto-generated method stub

		//for each agent, have the agent decide randomly whether to flip its cell's color
		for (Agent agent : agents) {
			if (Math.random() < 0.05) {
				//to decide which cell the agent is in... this is bad :( need to possibly flip it around, or decide
				//which cell each agent is in each time they move, in fact this could be determined using each agent's
				//x and y rather than searching all the cells... but this should be runnable for now
				for (int row = 0; row < cells.length; row++) {
					for (int col = 0; col < cells[row].length; col++) {
						if (cells[row][col].contains(agent.getCenterX(), agent.getCenterY())) {
							cells[row][col].flipColor();
						}
					}
				}
			}
		}

		//This is a temporary thing
		step();
		repaint();
	}

	@Override
	public void mouseMoved(MouseEvent e) {
		// TODO Auto-generated method stub
		
	}
}
